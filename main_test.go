package main

import (
	"fmt"
	"path/filepath"
	"reflect"
	"runtime"
	"testing"
)

// The key argument should be the AES key, either 16, 24, or 32 bytes select
// AES-128, AES-192, or AES-256. See http://golang.org/pkg/crypto/aes/#NewCipher
var key = []byte("A 32 byte key to select AES 256.")

func TestStringToFloat(t *testing.T) {
	var testValues = []struct {
		in  string
		out float64
	}{
		{"10.0001", 10.0001},
		{"123.245", 123.245},
		{".3452124", .3452124},
		{"293847239.000333", 293847239.000333},
		{"-98374.298347", -98374.298347},
		{"-1.2345", -1.2345},
		{"-0.987987", -0.987987},
		{"-.1234", -0.1234},
	}
	for _, tv := range testValues {
		res, err := stringToFloat(tv.in)
		ok(t, err)
		equals(t, tv.out, res)
	}
	res, err := stringToFloat("10.0.1.1")
	equals(t, true, err != nil)
	equals(t, 0.0, res)
}

func TestFloatToString(t *testing.T) {
	var testValues = []struct {
		in  float64
		out string
	}{
		{10.0001, "10.0001"},
		{123.245, "123.245"},
		{0.3452124, "0.3452124"},
		{293847239.000333, "293847239.000333"},
		{-98374.298347, "-98374.298347"},
		{-1.2345, "-1.2345"},
		{-0.987987, "-0.987987"},
		{-.1234, "-0.1234"},
	}
	for _, tv := range testValues {
		equals(t, tv.out, floatToString(tv.in))
	}
}

func TestEncodeBase64(t *testing.T) {
	var testValues = []struct {
		in  []byte
		out []byte
	}{
		{[]byte("Only dull people are brilliant at breakfast. O. Wilde"),
			[]byte{0x54, 0x32, 0x35, 0x73, 0x65, 0x53, 0x42, 0x6b, 0x64, 0x57, 0x78, 0x73, 0x49, 0x48, 0x42, 0x6c, 0x62, 0x33, 0x42, 0x73, 0x5a, 0x53, 0x42, 0x68, 0x63, 0x6d, 0x55, 0x67, 0x59, 0x6e, 0x4a, 0x70, 0x62, 0x47, 0x78, 0x70, 0x59, 0x57, 0x35, 0x30, 0x49, 0x47, 0x46, 0x30, 0x49, 0x47, 0x4a, 0x79, 0x5a, 0x57, 0x46, 0x72, 0x5a, 0x6d, 0x46, 0x7a, 0x64, 0x43, 0x34, 0x67, 0x54, 0x79, 0x34, 0x67, 0x56, 0x32, 0x6c, 0x73, 0x5a, 0x47, 0x55, 0x3d}},
		{[]byte("Art has never been made while thinking of art."),
			[]byte{0x51, 0x58, 0x4a, 0x30, 0x49, 0x47, 0x68, 0x68, 0x63, 0x79, 0x42, 0x75, 0x5a, 0x58, 0x5a, 0x6c, 0x63, 0x69, 0x42, 0x69, 0x5a, 0x57, 0x56, 0x75, 0x49, 0x47, 0x31, 0x68, 0x5a, 0x47, 0x55, 0x67, 0x64, 0x32, 0x68, 0x70, 0x62, 0x47, 0x55, 0x67, 0x64, 0x47, 0x68, 0x70, 0x62, 0x6d, 0x74, 0x70, 0x62, 0x6d, 0x63, 0x67, 0x62, 0x32, 0x59, 0x67, 0x59, 0x58, 0x4a, 0x30, 0x4c, 0x67, 0x3d, 0x3d}},
		{[]byte("Life can only be understood backwards; but it must be lived forwards. S. Kierkegaard"),
			[]byte{0x54, 0x47, 0x6c, 0x6d, 0x5a, 0x53, 0x42, 0x6a, 0x59, 0x57, 0x34, 0x67, 0x62, 0x32, 0x35, 0x73, 0x65, 0x53, 0x42, 0x69, 0x5a, 0x53, 0x42, 0x31, 0x62, 0x6d, 0x52, 0x6c, 0x63, 0x6e, 0x4e, 0x30, 0x62, 0x32, 0x39, 0x6b, 0x49, 0x47, 0x4a, 0x68, 0x59, 0x32, 0x74, 0x33, 0x59, 0x58, 0x4a, 0x6b, 0x63, 0x7a, 0x73, 0x67, 0x59, 0x6e, 0x56, 0x30, 0x49, 0x47, 0x6c, 0x30, 0x49, 0x47, 0x31, 0x31, 0x63, 0x33, 0x51, 0x67, 0x59, 0x6d, 0x55, 0x67, 0x62, 0x47, 0x6c, 0x32, 0x5a, 0x57, 0x51, 0x67, 0x5a, 0x6d, 0x39, 0x79, 0x64, 0x32, 0x46, 0x79, 0x5a, 0x48, 0x4d, 0x75, 0x49, 0x46, 0x4d, 0x75, 0x49, 0x45, 0x74, 0x70, 0x5a, 0x58, 0x4a, 0x72, 0x5a, 0x57, 0x64, 0x68, 0x59, 0x58, 0x4a, 0x6b}},
		{[]byte("Hysteria is only possible with an audience. C. Palahniuk"),
			[]byte{0x53, 0x48, 0x6c, 0x7a, 0x64, 0x47, 0x56, 0x79, 0x61, 0x57, 0x45, 0x67, 0x61, 0x58, 0x4d, 0x67, 0x62, 0x32, 0x35, 0x73, 0x65, 0x53, 0x42, 0x77, 0x62, 0x33, 0x4e, 0x7a, 0x61, 0x57, 0x4a, 0x73, 0x5a, 0x53, 0x42, 0x33, 0x61, 0x58, 0x52, 0x6f, 0x49, 0x47, 0x46, 0x75, 0x49, 0x47, 0x46, 0x31, 0x5a, 0x47, 0x6c, 0x6c, 0x62, 0x6d, 0x4e, 0x6c, 0x4c, 0x69, 0x42, 0x44, 0x4c, 0x69, 0x42, 0x51, 0x59, 0x57, 0x78, 0x68, 0x61, 0x47, 0x35, 0x70, 0x64, 0x57, 0x73, 0x3d}},
	}
	for _, tv := range testValues {
		equals(t, tv.out, encodeBase64(tv.in))
	}
}

func TestDecodeBase64(t *testing.T) {
	var testValues = []struct {
		out []byte
		in  []byte
	}{
		{[]byte("Only dull people are brilliant at breakfast. O. Wilde"),
			[]byte{0x54, 0x32, 0x35, 0x73, 0x65, 0x53, 0x42, 0x6b, 0x64, 0x57, 0x78, 0x73, 0x49, 0x48, 0x42, 0x6c, 0x62, 0x33, 0x42, 0x73, 0x5a, 0x53, 0x42, 0x68, 0x63, 0x6d, 0x55, 0x67, 0x59, 0x6e, 0x4a, 0x70, 0x62, 0x47, 0x78, 0x70, 0x59, 0x57, 0x35, 0x30, 0x49, 0x47, 0x46, 0x30, 0x49, 0x47, 0x4a, 0x79, 0x5a, 0x57, 0x46, 0x72, 0x5a, 0x6d, 0x46, 0x7a, 0x64, 0x43, 0x34, 0x67, 0x54, 0x79, 0x34, 0x67, 0x56, 0x32, 0x6c, 0x73, 0x5a, 0x47, 0x55, 0x3d}},
		{[]byte("Art has never been made while thinking of art."),
			[]byte{0x51, 0x58, 0x4a, 0x30, 0x49, 0x47, 0x68, 0x68, 0x63, 0x79, 0x42, 0x75, 0x5a, 0x58, 0x5a, 0x6c, 0x63, 0x69, 0x42, 0x69, 0x5a, 0x57, 0x56, 0x75, 0x49, 0x47, 0x31, 0x68, 0x5a, 0x47, 0x55, 0x67, 0x64, 0x32, 0x68, 0x70, 0x62, 0x47, 0x55, 0x67, 0x64, 0x47, 0x68, 0x70, 0x62, 0x6d, 0x74, 0x70, 0x62, 0x6d, 0x63, 0x67, 0x62, 0x32, 0x59, 0x67, 0x59, 0x58, 0x4a, 0x30, 0x4c, 0x67, 0x3d, 0x3d}},
		{[]byte("Life can only be understood backwards; but it must be lived forwards. S. Kierkegaard"),
			[]byte{0x54, 0x47, 0x6c, 0x6d, 0x5a, 0x53, 0x42, 0x6a, 0x59, 0x57, 0x34, 0x67, 0x62, 0x32, 0x35, 0x73, 0x65, 0x53, 0x42, 0x69, 0x5a, 0x53, 0x42, 0x31, 0x62, 0x6d, 0x52, 0x6c, 0x63, 0x6e, 0x4e, 0x30, 0x62, 0x32, 0x39, 0x6b, 0x49, 0x47, 0x4a, 0x68, 0x59, 0x32, 0x74, 0x33, 0x59, 0x58, 0x4a, 0x6b, 0x63, 0x7a, 0x73, 0x67, 0x59, 0x6e, 0x56, 0x30, 0x49, 0x47, 0x6c, 0x30, 0x49, 0x47, 0x31, 0x31, 0x63, 0x33, 0x51, 0x67, 0x59, 0x6d, 0x55, 0x67, 0x62, 0x47, 0x6c, 0x32, 0x5a, 0x57, 0x51, 0x67, 0x5a, 0x6d, 0x39, 0x79, 0x64, 0x32, 0x46, 0x79, 0x5a, 0x48, 0x4d, 0x75, 0x49, 0x46, 0x4d, 0x75, 0x49, 0x45, 0x74, 0x70, 0x5a, 0x58, 0x4a, 0x72, 0x5a, 0x57, 0x64, 0x68, 0x59, 0x58, 0x4a, 0x6b}},
		{[]byte("Hysteria is only possible with an audience. C. Palahniuk"),
			[]byte{0x53, 0x48, 0x6c, 0x7a, 0x64, 0x47, 0x56, 0x79, 0x61, 0x57, 0x45, 0x67, 0x61, 0x58, 0x4d, 0x67, 0x62, 0x32, 0x35, 0x73, 0x65, 0x53, 0x42, 0x77, 0x62, 0x33, 0x4e, 0x7a, 0x61, 0x57, 0x4a, 0x73, 0x5a, 0x53, 0x42, 0x33, 0x61, 0x58, 0x52, 0x6f, 0x49, 0x47, 0x46, 0x75, 0x49, 0x47, 0x46, 0x31, 0x5a, 0x47, 0x6c, 0x6c, 0x62, 0x6d, 0x4e, 0x6c, 0x4c, 0x69, 0x42, 0x44, 0x4c, 0x69, 0x42, 0x51, 0x59, 0x57, 0x78, 0x68, 0x61, 0x47, 0x35, 0x70, 0x64, 0x57, 0x73, 0x3d}},
	}
	for _, tv := range testValues {
		equals(t, tv.out, decodeBase64(tv.in))
	}

}

func TestEncryptDecrypt(t *testing.T) {
	var testValues = []struct {
		in []byte
	}{
		{[]byte("Natural selection is anything but random. R. Dawkins")},
		{[]byte("Goals transform a random walk into a chase. M. Csikszentmihalyi")},
		{[]byte("I do not fear computers. I fear the lack of them. I. Asimov")},
		{[]byte("I am patient with stupidity but not with those who are proud of it. E. Sitwell")},
	}
	for _, tv := range testValues {
		ctxt := encrypt(key, tv.in)          // encrypt
		equals(t, tv.in, decrypt(key, ctxt)) // decrypt
	}
}

func TestGobEncodeDecode(t *testing.T) {
	var testValues = []interface{}{
		"If you want to keep a secret, you must also hide it from yourself.",
		42,
		4.669201609,
		[]interface{}{1, "3", 5.0}, //map[string]struct{},
		map[string]struct{}{"one": struct{}{}, "two": struct{}{}},
	}
	for _, tv := range testValues {
		if gobbed, err := gobEncode(tv); err != nil {
			t.Errorf("Error gobEncoding %+v: %s", tv, err)
		} else {
			// This is pretty ugly there must be a better way
			// like to include the tv itself or include a variable in the
			// test values slice
			switch tv.(type) {
			case string:
				var ungobbed string
				err := gobDecode(gobbed, &ungobbed)
				ok(t, err)
				equals(t, fmt.Sprintf("%v", tv), fmt.Sprintf("%v", ungobbed))
			case int:
				var ungobbed int
				err := gobDecode(gobbed, &ungobbed)
				ok(t, err)
				equals(t, fmt.Sprintf("%v", tv), fmt.Sprintf("%v", ungobbed))
			case float64:
				var ungobbed float64
				err := gobDecode(gobbed, &ungobbed)
				ok(t, err)
				equals(t, fmt.Sprintf("%v", tv), fmt.Sprintf("%v", ungobbed))
			case []interface{}:
				var ungobbed []interface{}
				err := gobDecode(gobbed, &ungobbed)
				ok(t, err)
				equals(t, fmt.Sprintf("%v", tv), fmt.Sprintf("%v", ungobbed))
			case *map[string]struct{}:
				var ungobbed map[string]struct{}
				err := gobDecode(gobbed, &ungobbed)
				ok(t, err)
				equals(t, fmt.Sprintf("%v", tv), fmt.Sprintf("%v", ungobbed))
			}
		}
	}
}

func TestSigning(t *testing.T) {
	testValues := []struct {
		msg    []byte
		out    []byte
		secret []byte
	}{
		{
			[]byte(""),
			[]byte{0xb6, 0x13, 0x67, 0x9a, 0x8, 0x14, 0xd9, 0xec, 0x77, 0x2f, 0x95, 0xd7, 0x78, 0xc3, 0x5f, 0xc5, 0xff, 0x16, 0x97, 0xc4, 0x93, 0x71, 0x56, 0x53, 0xc6, 0xc7, 0x12, 0x14, 0x42, 0x92, 0xc5, 0xad},
			[]byte(""),
		},
		{[]byte(""),
			[]byte{0x8, 0x68, 0x18, 0x73, 0x19, 0x1c, 0xa3, 0xf5, 0x37, 0x23, 0x9, 0xa, 0xb6, 0xfa, 0x15, 0xf4, 0x4f, 0x55, 0xc0, 0xe4, 0xdf, 0x40, 0xe2, 0x28, 0xbd, 0x8e, 0xd8, 0xa6, 0x6b, 0x50, 0x82, 0xff},
			key},
		{[]byte("The secret to creativity is knowing how to hide your sources. A. Einstein"),
			[]byte{0xbd, 0x94, 0x99, 0xfd, 0x15, 0x1b, 0x50, 0xf5, 0x74, 0xaa, 0x79, 0x30, 0x8b, 0xff, 0x81, 0x2d, 0x5d, 0x58, 0x5f, 0xb3, 0x5a, 0x31, 0xad, 0xdd, 0x81, 0xf4, 0xf3, 0xe5, 0xe7, 0xf1, 0x4f, 0x97},
			key,
		},
		{[]byte("An undefined problem has an infinite number of solutions. R.A. Humphrey"),
			[]byte{0x92, 0x73, 0x51, 0xf5, 0xea, 0x8e, 0xf3, 0xe4, 0x26, 0x86, 0x28, 0x5a, 0x9b, 0xdd, 0xb9, 0xf5, 0x7a, 0x7a, 0xd, 0xaf, 0xa2, 0xf8, 0xa1, 0xc1, 0x83, 0x9b, 0x25, 0xed, 0xbd, 0xe7, 0xfa, 0x87},
			key},
		{[]byte("Make voyages! - Attempt them! - there's nothing else... T. Williams"),
			[]byte{0x2, 0x4d, 0x96, 0x60, 0xbd, 0x41, 0x59, 0x4, 0xaa, 0xb0, 0x73, 0x51, 0xc, 0xcb, 0x98, 0x8d, 0x4f, 0x5c, 0x8f, 0x7d, 0x38, 0x6, 0x9, 0x9d, 0x37, 0x62, 0x4b, 0x2, 0xe0, 0x2, 0xbe, 0xf4},
			key},
		{[]byte("You can't build a reputation on what you are going to do. H. Ford"),
			[]byte{0xfa, 0x9e, 0x39, 0x72, 0x1c, 0x2d, 0x96, 0x2b, 0x23, 0x60, 0x90, 0x8b, 0x50, 0xbe, 0x56, 0x72, 0xb, 0x5, 0xce, 0xf3, 0x69, 0xe3, 0xd5, 0xb9, 0x44, 0x55, 0xb7, 0xcc, 0x9c, 0xeb, 0x60, 0x7b},
			key},
	}
	for _, tv := range testValues {
		res := sign(tv.msg, tv.secret)
		equals(t, tv.out, res)
	}
}

func TestVerification(t *testing.T) {
	testValues := []struct {
		msg    []byte
		mac    []byte
		secret []byte
	}{
		{
			[]byte(""),
			[]byte{0xb6, 0x13, 0x67, 0x9a, 0x8, 0x14, 0xd9, 0xec, 0x77, 0x2f, 0x95, 0xd7, 0x78, 0xc3, 0x5f, 0xc5, 0xff, 0x16, 0x97, 0xc4, 0x93, 0x71, 0x56, 0x53, 0xc6, 0xc7, 0x12, 0x14, 0x42, 0x92, 0xc5, 0xad},
			[]byte(""),
		},
		{[]byte(""),
			[]byte{0x8, 0x68, 0x18, 0x73, 0x19, 0x1c, 0xa3, 0xf5, 0x37, 0x23, 0x9, 0xa, 0xb6, 0xfa, 0x15, 0xf4, 0x4f, 0x55, 0xc0, 0xe4, 0xdf, 0x40, 0xe2, 0x28, 0xbd, 0x8e, 0xd8, 0xa6, 0x6b, 0x50, 0x82, 0xff},
			key},
		{[]byte("The secret to creativity is knowing how to hide your sources. A. Einstein"),
			[]byte{0xbd, 0x94, 0x99, 0xfd, 0x15, 0x1b, 0x50, 0xf5, 0x74, 0xaa, 0x79, 0x30, 0x8b, 0xff, 0x81, 0x2d, 0x5d, 0x58, 0x5f, 0xb3, 0x5a, 0x31, 0xad, 0xdd, 0x81, 0xf4, 0xf3, 0xe5, 0xe7, 0xf1, 0x4f, 0x97},
			key,
		},
		{[]byte("An undefined problem has an infinite number of solutions. R.A. Humphrey"),
			[]byte{0x92, 0x73, 0x51, 0xf5, 0xea, 0x8e, 0xf3, 0xe4, 0x26, 0x86, 0x28, 0x5a, 0x9b, 0xdd, 0xb9, 0xf5, 0x7a, 0x7a, 0xd, 0xaf, 0xa2, 0xf8, 0xa1, 0xc1, 0x83, 0x9b, 0x25, 0xed, 0xbd, 0xe7, 0xfa, 0x87},
			key},
		{[]byte("Make voyages! - Attempt them! - there's nothing else... T. Williams"),
			[]byte{0x2, 0x4d, 0x96, 0x60, 0xbd, 0x41, 0x59, 0x4, 0xaa, 0xb0, 0x73, 0x51, 0xc, 0xcb, 0x98, 0x8d, 0x4f, 0x5c, 0x8f, 0x7d, 0x38, 0x6, 0x9, 0x9d, 0x37, 0x62, 0x4b, 0x2, 0xe0, 0x2, 0xbe, 0xf4},
			key},
		{[]byte("You can't build a reputation on what you are going to do. H. Ford"),
			[]byte{0xfa, 0x9e, 0x39, 0x72, 0x1c, 0x2d, 0x96, 0x2b, 0x23, 0x60, 0x90, 0x8b, 0x50, 0xbe, 0x56, 0x72, 0xb, 0x5, 0xce, 0xf3, 0x69, 0xe3, 0xd5, 0xb9, 0x44, 0x55, 0xb7, 0xcc, 0x9c, 0xeb, 0x60, 0x7b},
			key},
	}
	for _, tv := range testValues {
		equals(t, true, verify(tv.msg, tv.mac, tv.secret))
	}
}

// assert fails the test if the condition is false.
func assert(tb testing.TB, condition bool, msg string, v ...interface{}) {
	if !condition {
		_, file, line, _ := runtime.Caller(1)
		fmt.Printf("\033[31m%s:%d: "+msg+"\033[39m\n\n", append([]interface{}{filepath.Base(file), line}, v...)...)
		tb.FailNow()
	}
}

// ok fails the test if an err is not nil.
func ok(tb testing.TB, err error) {
	if err != nil {
		_, file, line, _ := runtime.Caller(1)
		fmt.Printf("\033[31m%s:%d: unexpected error: %s\033[39m\n\n", filepath.Base(file), line, err.Error())
		tb.FailNow()
	}
}

// equals fails the test if exp is not equal to act.
func equals(tb testing.TB, exp, act interface{}) {
	if !reflect.DeepEqual(exp, act) {
		_, file, line, _ := runtime.Caller(1)
		fmt.Printf("\033[31m%s:%d:\n\n\texp: %#v\n\n\tgot: %#v\033[39m\n\n", filepath.Base(file), line, exp, act)
		tb.FailNow()
	}
}
